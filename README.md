# Client-server Networking

This is a project The client is an Internet of Things (IoT) artifact in the form of an edge-based intelligent/smart refrigerator. It is edge-based because the refrigerator is installed in homes/RVs, which sit at the edge of the network. It is IoT-enabled because it is assumed to include a variety of sensors and networking support. 

Our smart refrigerator periodically sends two different types of messages to two different servers. The first message type that it can send out is a *Grocery Order* to a Grocery Server. The second message type that it can send is a *Health Status* to a Health Status Server. The servers in our assignment are very simple and respond with minimal information. The Grocery Server simply acknowledges with an “Order Placed” reply while the Health Status Server always responds with a “You Are Healthy”  reply. I mimic one such smart refrigerator, one Grocery Server and one Health Status server.
## Documentation

Refer to the following documentation files in the repository:
- `requirements.md`
- `design.md`
- `readme.md`

## System Structure
The system consists of:
- Skeleton code.
- Refrigerator, grocery server, health server, client, and server components.
- Custom application and transport protocols for communication between components.

## Operation

- Pad serialized buffer of order/status with bytes to create **1MB application-level packet** (only for requests).
- Impose a Maximum Transfer Unit (**MTU**) to 16 bytes. Divide the 1MB packet into 64 16-byte chunks, ensuring the order.
- For **GoBackN** and **SelectiveRepeat**, the sliding window size is set to **8 chunks** at a time. For the Alternating Bit protocol, the window size is always 1 chunk.
- Integrate skeleton code with dealer-router scaffolding code.
- No loss or delay of packets, but set artificial blocks.

## Strategy

At the network layer:
- When the **REQ** socket on the client or the **DEALER** socket in each intermediate router is ready to forward the chunk to the next hop, use random number logic to:
  - (a) send the chunk to the next hop
  - (b) delay it
  - (c) just don’t send it at all and drop it.


## Work Done

Implement reliable transfer in transport layer using different policies to ensure no flow/congestion control.

Use REQ socket at client, REQ socket at server, and DEALER-ROUTER socket at router. Format payload: [n/w adr dst IP] [transport seq] [appln payload]

ZMQ_REQ: when sending message, ZMQ inserts an empty frame at the front of message, when receiving the message, it removes the empty frame at front, return the message to appln layer

ZMQ_REP: when receiving message, save the envelope frames before the null frame, return the content after the null frame. When appln layer responds, the envelope frame abd null frame will be added.

ZMQ_ROUTER: when receiving a message, an envelope frame will be added at the front to mark the origin of message. It's specified by zmq_setsockopt(ZMQ_IDENTITY), also can be generated by receiver. When sending message, sends the content after envelope frame to the address marked as envelope frame.

ZMQ_DEALER: fair-queue the message received

## How to test

1. **sudo mn --topo=single,7 --link=tc**

2. **mininet> source commands_auto.txt**

   This command deploys two routers on h2 and h4, and a server on h6.

3. **xterm h1**

   Open xterm to see the output.

4. Under Node:h1, **python3 refrigerator.py -g 10.0.0.6 -p 4444**

   This command deploys a client on h1, sets the IP address of grocery store as 10.0.0.6, which is the IP address of h6, and sets the port as 4444.

After that, the client will consult the routing table, find next hop, and waits for the response.

Routers between the client and server will act in DEALER-ROUTER mode.

```
H1 10.0.0.5 H2
H1 10.0.0.6 H2
H2 10.0.0.5 H3
H2 10.0.0.6 H4
H3 10.0.0.5 H5
H3 10.0.0.6 H6
H4 10.0.0.5 H5
H4 10.0.0.6 H6
```

